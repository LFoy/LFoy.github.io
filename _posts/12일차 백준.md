1. 1463번 숫자 ‘1’ 만드는 최소 연산 수 찾기
    
    내 로직에 문제는 없는 것 같은데 시간 초과도 아니고 그냥 틀리다고 하네… 답지 보자ㅠㅠ
    
    답지 보니까 dp 로 푼다고 해서 다시 dp로 푸니까 10분 만에 맞춤;; 서식으로 안 풀릴때 dp로 풀려고해봤는데도 안풀리더니ㅠ_ㅠ
    
    ```
    n = int(input())
    cnt = 0
    dp = [0] * (n+1)
    dp[1] = 0
    
    for i in range(2, n+1):
        if i % 3 == 0:
            dp[i] = dp[i//3] + 1
        elif i % 2 == 0:
            dp[i] = min(dp[i-1], dp[i//2]) + 1
        else:
            dp[i] = dp[i-1] + 1
    
    print(dp[n])
    ```
    
    elif i % 2 == 0:  
    dp[i] = min(dp[i-1], dp[i//2]) + 1
    
    여기가 핵심이었음!
    
    아놔 이 풀이도 틀린거였음 ==i가 3이랑 2 둘다 나눠질때도 생각해야해서…==
    
    ```
    n = int(input())
    dp = [0] * (n+1)
    
    for i in range(2, n+1):
        dp[i] = dp[i-1] + 1
    
        if i % 2 == 0:
            dp[i] = min(dp[i-1], dp[i//2]) + 1
    
        if i % 3 == 0:
            dp[i] = min(dp[i-1], dp[i//3]) + 1
    
        if i % 3 == 0 and i % 2 ==0:
            dp[i] = min(dp[i-1], dp[i//3], dp[i//2]) + 1
        
    print(dp[n])
    ```
    
    이게 맞음ㅠ_ㅠ
    
    ==그리고 여기서 중요한 것!==
    
    ==elif를 절대 쓰지말것… 모든 경우를 고려하기 위해서==
    
    - 최솟값을 보장하는 dp 도 좋은데 최단거리를 보장하는 BFS도 쓸수 있음.
    
    ```
    Q=deque([x])
    visited=[0]*(x+1)
    while Q:
        c=Q.popleft()
        if c==1:
            break
        if c%3==0 and visited[c//3]==0:
            Q.append(c//3)
            visited[c//3]=visited[c]+1
        if c%2==0 and visited[c//2]==0:
            Q.append(c//2)
            visited[c//2]=visited[c]+1
        if visited[c-1]==0:
            Q.append(c-1)
            visited[c-1]=visited[c]+1
    print(visited[1])
    ```
    
    BFS도 elif 안씀 모든 경우를 고려해야하므로!
    
    예를 들어, ==x가 10일 때==, 2로 나누어 떨어지니까 visited[5]에는 1이 들어갑니다. 10에서 1을 빼면 visited[9]에도 1이 들어갑니다. 그러고 Q에는 각각 5와 9가 들어갑니다. 5일 때는 1을 빼는 연산을 한 번 더 하기 때문에, visited[4]에는 2가 들어갑니다. 9는 3으로 나누어 떨어지니까 visited[3]에도 2가 들어갑니다. 9에서 1뺀 visited[8]에도 2가 들어갑니다. 그러면 ==현재 Q에는 4,3,8이 들어있습니다. 이중 3에서 3으로 나누어 떨어지니까 바로 1이 되며,== visited[1]에는 3이 들어갑니다. 그래서 최종적으로 visited[1]을 출력하면 정답입니다.
    
    → 이해했다! 이미 방문한 집은 Q에 넣을 필요가 없어서 안 넣는구나! 그건 최소값이 절대 될 수 없으니까!
    
      
    
2. 1929번 m과 n 사이의 소수 찾기
    
    19분 걸림. 전날에 애라토스테네스의 소수 찾기 문제를 풀어서 그런지 소수 찾는 로직을 외우고 있어서 쉽게 푼듯…
    
    1) 2부터 n까지의 숫자 중 2의 배수를 제거한다.
    
    2) 제거하고 남은 수 중 최소값을 찾아 그 배수도 제거한다.
    
    3) 1), 2)를 반복하여 남은 수가 소수이다…
    
    근데 이거 전에 푼 사람들 보니까 실제로 list.remove 하면 시간 오래 걸리니까 visited로 푼게 기억나서 그걸로 풀었음… remove가 O(n) 이라 10^6이니까 최악은 10^12 여서 아마 시간초과로 못풀었을 수도…
    
    ```
    m, n = map(int, input().split())
    visited = [-1] * (n+1)
    prime = []
    
    for x in range(2, n+1):
        if visited[x] == -1:
            prime.append(x) 
    
            for i in range(x, n+1, x):
                visited[i] = 1
    
    for num in prime:
        if num >= m:
            print(num)
    ```
    
    여기서 사람들이 나처럼 x의 레인지를 2~(n+1)로 하지 않고 2~n**2 +1 즉 sqrt(n) 즉 루트n 으로 두길래 왜 그런가 했더니…
    
    ==n을 100이라고 생각하면 루트인 10 이하의 것들의 배수들만(n+1까지) 제거해도 10 이상의 배수들을 삭제할 수 있기 때문에. 아래는 블로그 글 발췌.==
    
    ==왼쪽 숫자인 1, 2, 4, 5, 10, 20, 25, 50, 100이 100의 약수입니다.== ==**가운데 10 x 10을 대칭으로 같은 연산이 반복된다**====는 것입니다. 10 x 10 이후로는 몫과 나누는 수가 대칭으로 반복되기 때문에 같은 연산을 두 번 할 필요는 없습니다. 여기서 10은 100의 제곱근, 즉 루트 100입니다. 루트 n을 기준으로 같은 연산이 대칭됩니다. 이를 이용해서 계산량을 줄일 수 있습니다.== ==**10 x 10 이전의 소수로만 나눗셈을 수행한 후 나누어 떨어지지 않으면 소수라고 판단**====할 수 있습니다.==