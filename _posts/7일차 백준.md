  

1. 9655번 돌 가져가기 게임 승자 맞추기
    
    17분 걸림.
    
    규칙 찾으려고 노력했음.
    

- 생각의 흐름

내가 가져갈 차례일때

n - sum(내가 가져가고 그동안 가져간 돌 개수) = 1 or 3 이 되면 무조건 짐

n - sum(그동안 가져간 돌 개수) = 2 이면 무조건 이김

4 이면 무조건 이김

= 5이면 무조건 짐(상대가 3 고를테니까)

= 6이면 무조건 이김

지는 조건 : 1, 3, 5

이기는 조건 : 2,4,6 ( 그러니까 내가 돌을 가져갔을때 남은 개수가 짝수일수만 있으면 이김)

```
n = int(input())

if n % 2 == 0:
    print('CY')
else:
    print('SK')
```

걍 다 이렇게 풀었는데?

  

1. 1439번 0,1 숫자 뒤집는 횟수 구하기
    
    15분 걸림.
    
    처음엔 이렇게 생각함.  
    1이 연속된 숫자의 개수 새기  
    0이 연속된 숫자의 개수 새기  
    print(min(li))
    
    리스트로 카운트 하려고 했는데 생각해보니까 1과 0이 뭔지 아는게 중요하지 않고 뭐가 됐든 최소값만 알면 된다는데까지 생각이 미치고 그럼 그냥 다른 횟수로만 규칙을 찾을수 있겠다 싶어서 생각하다보니 예시 몇개 해보고 결론 구함.
    
    ```
    import math
    
    s = input()
    cnt = 0
    
    for idx in range(len(s)-1):
        if s[idx] != s[idx+1]:
            cnt += 1
    
    print(math.ceil(cnt/2))
    ```
    
    신기하게 푼사람 있음.
    
    ```
    s=input()
    a=s.split('0')
    b=s.split('1')
    
    a_len=len([n for n in a if n!=''])
    b_len=len([n for n in b if n!=''])
    print(min(a_len,b_len))
    ```
    
    ==100010.split(’0’) 하면==
    
    ==[’1’, ‘’, ‘’, ‘’, ‘1’, ‘’]==
    
    ==으로 나옴..;;==
    
    ==100010.split(’1’)하면==
    
    ==[’’, ‘000’, ‘0’] 나옴==
    
    ==아 좀 신기하다 이거==
    
      
    
2. 11004 N개의 수를 정렬한 뒤 K번째 수 찾기
    
    못풀겠음… min, max로 해보려고했는데 시간초과 나옴
    
    엥? 그냥 list.sort() 쓰면 되네?
    
    리스트 정렬은 NlogN 이라서 된대;;
    
    아 근데 좀 바보다. sort한번 트라이라도 해보지 못하겠다고 답을 보냐… 에흉
    
      
    
3. 2167번 2차원 배열 특정 구간 합 구하기
    
    아 이거 왜 안풀리냐 두가지 방식으로 풀었는데 둘다 시간초과 나요;
    
    이중 포문 했는데 시간초과 나서
    
    포문 하나에 sum(list) 함수 썼는데도 시간초과 뜨는데? 도대체 뭘 어떻게 해야되는데.
    
    ==결국 못풀어서 답지 보니까 DP 로 풀어야함.==
    
    - 누적합과 구간합
    
    [https://ywtechit.tistory.com/102](https://ywtechit.tistory.com/102)
    
    2차원 배열로 생각하면 어려우니까 1차원 배열로 개념 설명.
    
    i) 누적합 : 10^8의 1차원 리스트가 주어졌을때 1차원 리스트의 특정 인덱스까지의 합을 10^8번 묻는다고 하자.
    
    sum함수는 O(n)을 가지므로 len(list)인 10^8 과 묻는 수 10^8을 곱하면 O(10^16)이 된다. 물을때마다 sum함수를 사용해서 답을 내게 되면 이렇듯 시간초과가 나게된다.
    
    근데 만약 인덱스 0부터 len(list)까지 모든 인덱스마다의 합을 미리 구해놓고 dp라는 리스트에 그 값을 저장해놓는다면?
    
    ==**그 시간은 1 * 2 …. * 10^7 * … * 10^8 즉 O(10^8~9) 정도밖에 안된다.**==
    
    ==**→ 이 부분이 잘못 이해한 부분**==
    
    → ==이게 아니라==
    
    ==dp[n] = dp[n-1] + arr[n] 이렇게 구할수 있으므로 O(10^8) 즉 빅오 len(list)밖에 안되는것이다. sum함수(O(n))를 len(list) 만큼하는게 아니라! 이 바보야!==
    
    그리고 10^8번 물을때마다 dp[index] 즉 O(1)의 시간으로 답을 해주면되니까 O(10^8~9) 를 유지하게 된다!
    
    이것이 바로 누적합 DP 방식이 필요한 이유이다.
    
      
    
    ii) 구간합: 누적합과 비슷하나
    
    누적합은 1차원 배열의 리스트에 인덱스 0 부터 특정 인덱스 i까지의 합이라고 한다면
    
    구간합은 1차원 배열의 리스트에 특정 인덱스 i부터 특정 인덱스 j까지의 합을 의미하지 않는다! → 어우 큰일날뻔 했네. 이렇게 이해하면 구간합 방식도 O(10^16)으로 동일해진다;;
    
    구간합은 누적합을 dp 리스트로 구하고
    
    i부터 j까지의 구간합 = dp[j] - dp[i]
    
    로 나타낼수 있어 누적합과 동일한 빅오를 가지게 된다.
    
    ==이 개념을 2차원 리스트로 확장시키면==
    
    ==2차원 배열의 특정 사각형 구간의 합을 구하려고 할때 구간 합을 묻는 횟수가 한번이 아니라 아주아주 많다면==
    
    ==2차원 리스트의 누적합을 구하는 2차원 리스트인 dp를 구해놓고.==
    
    ==구간합을 물을때마다 = dp[전][체] - dp[윗][부] - dp[왼][쪽] + dp[중][복]==
    
    ==을 해주면 2차원 리스트의 누적합을 구하는 빅오와 동일해지기 때문에 이 방식을 이용해야한다!==
    
    하 개념 이해하고 dp로 또 한시간 더 풀었는데 그래도 시간초과 나네;; 뭐가 문제야 도대체. 아 dp를 구할때 누적합 수식이
    
    dp[n] = list[n] + dp[n-1]
    
    이런식으로 재귀적으로 짜여야함. 내가 위에서 개념 이해를 아예 잘못한거였음. dp 구성할때 4중 포문을 만들고는 왜 안되냐고 징징댔군…
    
    - ==누적합 dp 구할때 1차원 리스트면 맨앞 dp[0] 이 무조건 0 이어야하고, 2차원 리스트면 이런식으로 dp[0][]과 dp[][0]이 0이어야함. 그래야 인덱스가 마이너스가 되는 걸 막을 수 있음.(재귀함수에 기초 값이 있듯이)==
    
    0 0 0 0 0 0
    
    0 v v v v v
    
    0 v v v v v
    
    0 v v v v v
    
    드디어 풀었다 하… 몇시간 만에 푼거냐.
    
    그래도 dp 공부 열심히 했다…
    
    ```
    from sys import stdin
    
    row, col = map(int, input().split())
    base = []
    
    for _ in range(row):
        base.append(list(map(int, stdin.readline().split())))
    
    dp = [[0 for _ in range(col+1)] for _ in range(row+1)]
    
    for i in range(1, row+1):
        for j in range(1, col+1):
            dp[i][j] = dp[i][j-1] + dp[i-1][j] - dp[i-1][j-1] + base[i-1][j-1]       
    
    k = int(input())
    
    for _ in range(k):
        i, j, x, y = map(int, stdin.readline().split())
        print(dp[x][y] - dp[x][j-1] - dp[i-1][y] + dp[i-1][j-1])
    ```
    
    여기서 특히나 어려웠던건 dp[][] 인덱스 안에 들어갈 4가지 짝을 찾는게 어려웠는데 한번 해봤으니까 다음에 할땐 좀더 쉽게 생각할 수 있겠지…
    

  

1. 25206번 학점 평점 계산기
    
    18분 걸림.
    
    쉬웠는데 포맷팅 하는거 생각 안나서 다시 찾아봄 ㅎㅎ;;
    
    ```
    sum = 0
    grades = {'A+' : 4.5, 'A0' : 4.0, 'B+' : 3.5, 'B0' : 3.0, 'C+' : 2.5, 'C0' : 2.0, 'D+' : 1.5, 'D0' : 1.0, 'F' : 0.0}
    credits = 0
    
    for _ in range(20):
        name, credit, grade = map(str, input().split())
        
        if grade == 'P':
            continue
        
        sum += float(credit) * grades[grade]
        credits += float(credit)
    
    print(f'{sum / credits : .6f}')
    ```
    
    f’{숫자 : 서식자}’
    
    :::::::::::::: : 이거야 바보야 %이거는 퍼센테이지 서식자고 ㅋ;;
    
    ==아 그리고 ‘3.0’ 문자열 int() 함수로 못바꿈 float() 함수로 숫자로 바꿀 수 있음!==
    

  

1. 7785번 출입 로그로 출근자 확인하기
    
    10분 걸림. 쉬웠음. 이 아니라 15분 걸림;;
    
    이거 보자마자 풀긴했는데 리스트로 풀어서;;
    
    not in, in 연산자 사용하면 무조건 딕셔너리로 풀어야지 바보야!
    
    ```
    from sys import stdin
    
    n = int(input())
    people = {}
    
    for _ in range(n):
        name, log= map(str, stdin.readline().rstrip().split())
        if name not in people:
            people[name] = 0    
        
        else:
            del people[name]
    
    print(*sorted(people.keys(), reverse = True), sep = '\n')
    ```
    
    이름을 기준으로 토글처럼 풀었음
    
    다 비슷하게 풀었네…